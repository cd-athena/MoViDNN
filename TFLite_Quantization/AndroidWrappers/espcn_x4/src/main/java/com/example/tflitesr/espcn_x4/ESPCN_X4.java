// Generated by TFLite Support.
package com.example.tflitesr.espcn_x4;

import android.content.Context;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.tensorflow.lite.DataType;
import org.tensorflow.lite.Tensor;
import org.tensorflow.lite.Tensor.QuantizationParams;
import org.tensorflow.lite.support.common.FileUtil;
import org.tensorflow.lite.support.common.TensorProcessor;
import org.tensorflow.lite.support.common.ops.CastOp;
import org.tensorflow.lite.support.common.ops.DequantizeOp;
import org.tensorflow.lite.support.common.ops.NormalizeOp;
import org.tensorflow.lite.support.common.ops.QuantizeOp;
import org.tensorflow.lite.support.image.ImageProcessor;
import org.tensorflow.lite.support.image.TensorImage;
import org.tensorflow.lite.support.image.ops.ResizeOp;
import org.tensorflow.lite.support.image.ops.ResizeOp.ResizeMethod;
import org.tensorflow.lite.support.label.Category;
import org.tensorflow.lite.support.label.TensorLabel;
import org.tensorflow.lite.support.metadata.MetadataExtractor;
import org.tensorflow.lite.support.metadata.schema.NormalizationOptions;
import org.tensorflow.lite.support.model.Model;
import org.tensorflow.lite.support.tensorbuffer.TensorBuffer;

/** Wrapper class of model ESPCN X4 Model for SR-ABR (Version: unknown) */
public class ESPCN_X4 {
  private final Metadata metadata;
  private final Model model;
  private static final String MODEL_NAME = "espcn_x4.tflite";
  private ImageProcessor lrImagePreprocessor;
  private ImageProcessor srImagePostprocessor;

  /** Output wrapper of {@link ESPCN_X4} */
  public static class Outputs {
    private final TensorImage srImage;
    private final ImageProcessor srImagePostprocessor;

    public TensorImage getSrImageAsTensorImage() {
      return postprocessSrImage(srImage);
    }

    Outputs(Metadata metadata, ImageProcessor srImagePostprocessor) {
      srImage = new TensorImage(metadata.getSrImageType());
      srImage.load(TensorBuffer.createFixedSize(metadata.getSrImageShape(), metadata.getSrImageType()));
      this.srImagePostprocessor = srImagePostprocessor;
    }

    Map<Integer, Object> getBuffer() {
      Map<Integer, Object> outputs = new HashMap<>();
      outputs.put(0, srImage.getBuffer());
      return outputs;
    }

    private TensorImage postprocessSrImage(TensorImage tensorImage) {
      return srImagePostprocessor.process(tensorImage);
    }
  }

  /** Metadata accessors of {@link ESPCN_X4} */
  public static class Metadata {
    private final int[] lrImageShape;
    private final DataType lrImageDataType;
    private final QuantizationParams lrImageQuantizationParams;
    private final float[] lrImageMean;
    private final float[] lrImageStddev;
    private final int[] srImageShape;
    private final DataType srImageDataType;
    private final QuantizationParams srImageQuantizationParams;
    private final float[] srImageMean;
    private final float[] srImageStddev;

    public Metadata(ByteBuffer buffer, Model model) throws IOException {
      MetadataExtractor extractor = new MetadataExtractor(buffer);
      Tensor lrImageTensor = model.getInputTensor(0);
      lrImageShape = lrImageTensor.shape();
      lrImageDataType = lrImageTensor.dataType();
      lrImageQuantizationParams = lrImageTensor.quantizationParams();
      NormalizationOptions lrImageNormalizationOptions =
          (NormalizationOptions) extractor.getInputTensorMetadata(0).processUnits(0).options(new NormalizationOptions());
      FloatBuffer lrImageMeanBuffer = lrImageNormalizationOptions.meanAsByteBuffer().asFloatBuffer();
      lrImageMean = new float[lrImageMeanBuffer.limit()];
      lrImageMeanBuffer.get(lrImageMean);
      FloatBuffer lrImageStddevBuffer = lrImageNormalizationOptions.stdAsByteBuffer().asFloatBuffer();
      lrImageStddev = new float[lrImageStddevBuffer.limit()];
      lrImageStddevBuffer.get(lrImageStddev);
      Tensor srImageTensor = model.getOutputTensor(0);
      srImageShape = srImageTensor.shape();
      srImageDataType = srImageTensor.dataType();
      srImageQuantizationParams = srImageTensor.quantizationParams();
      NormalizationOptions srImageNormalizationOptions =
          (NormalizationOptions) extractor.getInputTensorMetadata(0).processUnits(0).options(new NormalizationOptions());
      FloatBuffer srImageMeanBuffer = srImageNormalizationOptions.meanAsByteBuffer().asFloatBuffer();
      srImageMean = new float[srImageMeanBuffer.limit()];
      srImageMeanBuffer.get(srImageMean);
      FloatBuffer srImageStddevBuffer = srImageNormalizationOptions.stdAsByteBuffer().asFloatBuffer();
      srImageStddev = new float[srImageStddevBuffer.limit()];
      srImageStddevBuffer.get(srImageStddev);
    }

    public int[] getLrImageShape() {
      return Arrays.copyOf(lrImageShape, lrImageShape.length);
    }

    public DataType getLrImageType() {
      return lrImageDataType;
    }

    public QuantizationParams getLrImageQuantizationParams() {
      return lrImageQuantizationParams;
    }

    public float[] getLrImageMean() {
      return Arrays.copyOf(lrImageMean, lrImageMean.length);
    }

    public float[] getLrImageStddev() {
      return Arrays.copyOf(lrImageStddev, lrImageStddev.length);
    }

    public int[] getSrImageShape() {
      return Arrays.copyOf(srImageShape, srImageShape.length);
    }

    public DataType getSrImageType() {
      return srImageDataType;
    }

    public QuantizationParams getSrImageQuantizationParams() {
      return srImageQuantizationParams;
    }

    public float[] getSrImageMean() {
      return Arrays.copyOf(srImageMean, srImageMean.length);
    }

    public float[] getSrImageStddev() {
      return Arrays.copyOf(srImageStddev, srImageStddev.length);
    }
  }

  public Metadata getMetadata() {
    return metadata;
  }

  /**
   * Creates interpreter and loads associated files if needed.
   *
   * @throws IOException if an I/O error occurs when loading the tflite model.
   */
  public static ESPCN_X4 newInstance(Context context) throws IOException {
    return newInstance(context, MODEL_NAME, new Model.Options.Builder().build());
  }

  /**
   * Creates interpreter and loads associated files if needed, but loading another model in the same
   * input / output structure with the original one.
   *
   * @throws IOException if an I/O error occurs when loading the tflite model.
   */
  public static ESPCN_X4 newInstance(Context context, String modelPath) throws IOException {
    return newInstance(context, modelPath, new Model.Options.Builder().build());
  }

  /**
   * Creates interpreter and loads associated files if needed, with running options configured.
   *
   * @throws IOException if an I/O error occurs when loading the tflite model.
   */
  public static ESPCN_X4 newInstance(Context context, Model.Options runningOptions) throws IOException {
    return newInstance(context, MODEL_NAME, runningOptions);
  }

  /**
   * Creates interpreter for a user-specified model.
   *
   * @throws IOException if an I/O error occurs when loading the tflite model.
   */
  public static ESPCN_X4 newInstance(Context context, String modelPath, Model.Options runningOptions) throws IOException {
    Model model = Model.createModel(context, modelPath, runningOptions);
    Metadata metadata = new Metadata(model.getData(), model);
    ESPCN_X4 instance = new ESPCN_X4(model, metadata);
    instance.resetLrImagePreprocessor(
        instance.buildDefaultLrImagePreprocessor());
    instance.resetSrImagePostprocessor(
        instance.buildDefaultSrImagePostprocessor());
    return instance;
  }


  public void resetLrImagePreprocessor(ImageProcessor processor) {
    lrImagePreprocessor = processor;
  }

  public void resetSrImagePostprocessor(ImageProcessor processor) {
    srImagePostprocessor = processor;
  }

  /** Triggers the model. */
  public Outputs process(TensorImage lrImage) {
    Outputs outputs = new Outputs(metadata, srImagePostprocessor);
    Object[] inputBuffers = preprocessInputs(lrImage);
    model.run(inputBuffers, outputs.getBuffer());
    return outputs;
  }

  /** Closes the model. */
  public void close() {
    model.close();
  }

  private ESPCN_X4(Model model, Metadata metadata) {
    this.model = model;
    this.metadata = metadata;
  }

  private ImageProcessor buildDefaultLrImagePreprocessor() {
    ImageProcessor.Builder builder = new ImageProcessor.Builder()
        .add(new ResizeOp(
            metadata.getLrImageShape()[1],
            metadata.getLrImageShape()[2],
            ResizeMethod.NEAREST_NEIGHBOR))
        .add(new NormalizeOp(metadata.getLrImageMean(), metadata.getLrImageStddev()))
        .add(new QuantizeOp(
            metadata.getLrImageQuantizationParams().getZeroPoint(),
            metadata.getLrImageQuantizationParams().getScale()))
        .add(new CastOp(metadata.getLrImageType()));
    return builder.build();
  }

  private ImageProcessor buildDefaultSrImagePostprocessor() {
    ImageProcessor.Builder builder = new ImageProcessor.Builder()
        .add(new DequantizeOp(
            metadata.getSrImageQuantizationParams().getZeroPoint(),
            metadata.getSrImageQuantizationParams().getScale()))
        .add(new NormalizeOp(metadata.getSrImageMean(), metadata.getSrImageStddev()));
    return builder.build();
  }

  private Object[] preprocessInputs(TensorImage lrImage) {
    lrImage = lrImagePreprocessor.process(lrImage);
    return new Object[] {lrImage.getBuffer()};
  }
}

